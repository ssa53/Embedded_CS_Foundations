## 01. Array (배열 기반 Sequence ADT)

###핵심 요약
- **직접 접근:** 인덱스를 활용한 $O(1)$ 접근 성능 확인.
- **메모리 구조:** 연속된 메모리 공간을 사용하여 캐시 효율성을 극대화함.
- **임베디드 적합성:** 고정된 크기의 배열을 사용하여 메모리 사용의 예측 가능성(Predictability) 확보.

###내가 애먹었던 부분 (Troubleshooting)
- **역방향 시프팅의 직관적 이해:** `add` 연산 시 데이터를 뒤로 밀 때, 앞에서부터 밀면 값이 덮어씌워진다는 것을 확인함. 이를 해결하기 위해 `for (int i = n; i > idx; i--)`와 같이 **역순으로 접근**해야 함을 체득함.
- **경계 조건(Boundary Condition) 처리:** `remove` 시 `i < n - 1` 범위를 잘못 설정하면 배열 밖의 쓰레기 값을 참조하는 에러가 발생. 이를 방지하기 위해 엄격한 **Index Check** 로직을 모든 함수에 추가.

###성능 분석 ($Time Complexity$)
- **At / Set:** $O(1)$
- **Add / Remove:** $O(n)$ (데이터 이동 오버헤드 발생)
